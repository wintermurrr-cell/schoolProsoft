global _start ; Объявляем точку входа _start глобальной

section .data   ; Секция инициализированных данных

enter_msg db "Enter your string: ", 0 ; Сообщение которым будем приглашать пользователя ввести текст
enter_msg_len equ $ - enter_msg ; Вычисление длины строки

result_msg db "Reversed: ", 0 ; Сообщение которое будем выводить перед развернутой строкой
result_msg_len equ $ - result_msg  ; Вычисление длины строки

error_msg db "an error occurred while executing the program", 10 ; Сообщение которое будем выводить при ошибке "во время выполнения программы произошла ошибка", с переходом на новую строку(10)
error_msg_len equ $ - error_msg ; Вычисление длины строки

section .bss ; Секция неинициализированных данных
user_text resb 100 ; Резервируем 100 байт для пользовательского текста
user_text_len resd 1  ; Длина строки в байтах, которую ввел пользователь
reverse_text resb 100 ; Резервируем 100 байт для развернутого текста
reverse_text_len equ $ - reverse_text ; Вычисление длины реверсированной строки

section .text  ; Секция текста программы
_start: ; Точка входа программы

; Вывод текста в консоль
mov rax, 1 ; write (системный вызов)
mov rdi, 1 ; дескриптор файла стандартного вызова stdout
mov rsi, enter_msg  ; адрес строки для вывода
mov rdx, enter_msg_len ; количество байтов
syscall ; Выполняем системный вызов вывода

cmp rax, 0 ; Сравниваем возвращаемое значение с 0
jl error_end ;Если число отрицательное - значит ошибка

cmp rax, enter_msg_len ; Сравниваем возвращенное значение с длинной
jl error_end ; Если не равно - ошибка

; Считываем текст введенный пользователем
mov rax, 0 ; read (системный вызов)чтение
mov rdi, 0 ; Читаем поток stdin
mov rsi, user_text; Считываемый текст в переменную
mov rdx, 100 ; максимальное количество байт для чтения
syscall ; выполняем системный вызов чтения

mov [user_text_len], rax ; пишем в переменную длину строки, которую ввел пользователь

cmp rax, 0 ; Проверка возвращаемого значения системного вызова
jl error_end ;Если число отрицательное - значит ошибка

mov rax, [user_text] ; Загружаем первый символ
cmp rax, 10 ; Сравниваем с переносом строки
jz error_end ; Если этот символ перенос строки - ошибка

call text_reverse ; Вызов функции для переворачивания текста

; Вывод текста в консоль
mov rax, 1  ; write (системный вызов)
mov rdi, 1  ; дескриптор файла стандартного вызова stdout
mov rsi, result_msg  ; адрес строки для вывода
mov rdx, result_msg_len ; количество байтов для вывода
syscall ; Выполняем системный вызов вывода

cmp rax, 0 ; Проверка успешности вывода
jl error_end ;Если число отрицательное - значит ошибка

cmp rax, result_msg_len ; Сравнение количества записанных байт с ожидаемой длиной
jl error_end ; Ошибка если записано другое кол-во байт чем ожидалось

; Вывод реверсивного текста в консоль
mov rax, 1 ; write (системный вызов)
mov rdi, 1  ; дескриптор файла стандартного вызова stdout
mov rsi, reverse_text ; адрес строки для вывода
mov rdx, reverse_text_len ; количество байтов для вывода
syscall ; Выполняем системный вызов вывода

cmp rax, 0 ; Проверка успешности вывода
jl error_end ; Переход к ошибке если вернулось отрицательное значение
cmp rax, reverse_text_len ; Сравнение длины записанных байт с ожидаемой длиной
jl error_end; переход к ошибке если другое кол-во байт чем ожидалось

; Выход из программы
mov rax, 60 ; exit (системный вызов)
mov rdi, 0 ; код успешного выхода из программы
syscall ; Системный вызов exit (успешное завершение)

error_end:;Обработка ошибок
mov rax, 1 ; write (системный вызов)
mov rdi, 2 ; дескриптор файла стандартного вызова stdout
mov rsi, error_msg  ; адрес строки для вывода
mov rdx, error_msg_len ; количество байтов
syscall;  Системный вызов вывода сообщения об ошибке

mov rax, 60 ; exit (системный вызов)
mov rdi, 2 ; код выхода из программы с ошибкой
syscall ; Вызов системной функции выход с кодом ошибки

text_reverse: ; Функция для переворота текстовой строки через стек
mov rsi, user_text ; Помещаем адрес первого символа введенный пользователем в переменную
mov rcx, [user_text_len] ; Указываем число повторений для loop

stack_loop_push: ; помещаем символы в стек
lodsb   ; помещаем символ из RSI в RAX и перемещаемся на элемент вправо
push rax ; помещаем букву в стек

loop stack_loop_push    ; Повторение перемещения на тег пока RCX не будет равен нулю
; Продолжаем выполнение text_reverse

mov rcx, [user_text_len]  ; Указываем число повторений для loop
mov r9, reverse_text  ; Помещаем в r9 адрес на первый символ массива reverse_text

stack_loop_pop: ; извлечение символов из стека
pop rax ; Извлекаем в rax верхний элемент стека
mov [r9], al  ; Помещаем букву в ячейку массива
lea r9, [r9 + 1] ; Записываем в r9 адрес следующей ячейки

loop stack_loop_pop ; Повторения цикла перемещенеия на тег пока RCX не будет равен нулю
; Продолжаем выполнение text_reverse

mov byte [r9], 10 ; После вывода реверсного текста, перенос строки

ret ; Возврат из функции
